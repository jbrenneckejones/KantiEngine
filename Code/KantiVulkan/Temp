
#if 0

// Render object







struct vulkan_constructor
{
	vulkan_base_properties BaseProperties;

	vulkan_rendering_properties RenderProperties;

	vulkan_device_properties DeviceProperties;

	vulkan_command_buffers CommandBuffers;

	vulkan_pipeline_properties PipelineProperties;

	vulkan_shader_resources Shaders;

	vulkan_debug_properties DebugLayer;

	// Synchronization semaphores
	struct {
		// Swap chain image presentation
		VkSemaphore PresentComplete;
		// Command buffer submission and execution
		VkSemaphore RenderComplete;
	} Semaphores;

	struct {
		VkPipelineVertexInputStateCreateInfo InputState;
		VkVertexInputBindingDescription* BindingDescriptions;
		VkVertexInputAttributeDescription* AttributeDescriptions;
	} Vertices;

	struct {
		VkPipeline Solid;
	} Pipelines;

	// Vulkan instance, stores all per-application states
	VkInstance Instance;
	// Handle to the device graphics queue that command buffers are submitted to
	VkQueue Queue;
	// Contains command buffers and semaphores to be presented to the queue
	VkSubmitInfo SubmitInfo;
	// Wraps the swap chain to present images (framebuffers) to the windowing system
	vulkan_swap_chain SwapChain;

	VkDescriptorSetLayout DescriptorSetLayout;

	struct 
	{
		VkImage Image;
		VkDeviceMemory Memory;
		VkImageView View;
	} DepthStencil;

	vulkan_constructor(renderer_platform& Platform, vulkan_base_properties& Properties)
	{
		// Window = (HWND)Platform.Window;
		// WindowInstance = (HINSTANCE)Platform.Instance;

		// Check for validation command line flag
		/*
		for (int32 i = 0; i < __argc; i++)
		{
		if (__argv[i] == std::string("-validation"))
		{
		enableValidation = true;
		}
		if (__argv[i] == std::string("-vsync"))
		{
		enableVSync = true;
		}
		}
		*/

		BaseProperties = Properties;

		// Enable console if validation is active
		// Debug message callback will output to it
		if (Properties.EnableValidation)
		{
			// setupConsole("VulkanExample");
		}
	}

	// Create application wide Vulkan instance
	VkResult CreateInstance(bool32 VulkanEnableValidation)
	{
		BaseProperties.EnableValidation = VulkanEnableValidation;

		VkApplicationInfo ApplicationInfo = {};
		ApplicationInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
		ApplicationInfo.pApplicationName = BaseProperties.ApplicationName;
		ApplicationInfo.pEngineName = BaseProperties.ApplicationName;
		ApplicationInfo.apiVersion = VK_API_VERSION_1_0;

		uint32 ExtensionCount = 2;
		const char* EnabledExtensions[3] = { VK_KHR_SURFACE_EXTENSION_NAME, VK_KHR_WIN32_SURFACE_EXTENSION_NAME };

		VkInstanceCreateInfo InstanceCreateInfo = {};
		InstanceCreateInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
		InstanceCreateInfo.pNext = NULL;
		InstanceCreateInfo.pApplicationInfo = &ApplicationInfo;
		if (ExtensionCount > 0)
		{
			if (VulkanEnableValidation)
			{
				ExtensionCount++;
				EnabledExtensions[2] = VK_EXT_DEBUG_REPORT_EXTENSION_NAME;
			}
			InstanceCreateInfo.enabledExtensionCount = (uint32)ExtensionCount;
			InstanceCreateInfo.ppEnabledExtensionNames = EnabledExtensions;
		}
		if (VulkanEnableValidation)
		{
			uint32 ValidationLayerCount = 1;
			const char* ValidationLayerNames[] = 
			{
				// This is a meta layer that enables all of the standard
				// validation layers in the correct order :
				// threading, parameter_validation, device_limits, object_tracker, image, core_validation, swapchain, and unique_objects
				"VK_LAYER_LUNARG_standard_validation"
			};

			InstanceCreateInfo.enabledLayerCount = ValidationLayerCount;
			InstanceCreateInfo.ppEnabledLayerNames = ValidationLayerNames;
		}
		return vkCreateInstance(&InstanceCreateInfo, nullptr, &Instance);
	}

	// Returns the base asset path (for shaders, models, textures) depending on the os
	const char* GetAssetPath()
	{
		return "./../Data/";
	}

	// Called if the window is resized and some resources have to be recreatesd
	void WindowResize()
	{
		if (!RenderProperties.Prepared)
		{
			return;
		}
		RenderProperties.Prepared = false;

		// Recreate swap chain
		RenderProperties.Width = BaseProperties.DestinationWidth;
		RenderProperties.Height = BaseProperties.DestinationHeight;
		CommandBuffers.CreateSetupCommandBuffer(DeviceProperties.Device);
		CreateSwapChainImages();

		// Recreate the frame buffers

		vkDestroyImageView(DeviceProperties.Device, DepthStencil.View, nullptr);
		vkDestroyImage(DeviceProperties.Device, DepthStencil.Image, nullptr);
		vkFreeMemory(DeviceProperties.Device, DepthStencil.Memory, nullptr);
		SetupDepthStencil();

		for (uint32 Index = 0; Index < CommandBuffers.FrameBuffersCount; Index++)
		{
			vkDestroyFramebuffer(DeviceProperties.Device, CommandBuffers.FrameBuffers[Index], nullptr);
		}
		CommandBuffers.SetupFrameBuffer(RenderProperties.Width, RenderProperties.Height, DepthStencil.View, &SwapChain);

		CommandBuffers.FlushSetupCommandBuffer(DeviceProperties.Device);

		// Command buffers need to be recreated as they may store
		// references to the recreated frame buffer
		CommandBuffers.DestroyCommandBuffers(DeviceProperties.Device);
		CommandBuffers.CreateCommandBuffers(SwapChain.ImageCount);

		CommandBuffers.BuildCommandBuffers(RenderProperties.DefaultClearColor, RenderProperties.Width, RenderProperties.Height, Pipelines.Solid, PipelineProperties.PipelineLayout, DescriptorSetLayout, );
		CommandBuffers.BuildPresentCommandBuffers(DeviceProperties.Device);

		vkQueueWaitIdle(Queue);
		vkDeviceWaitIdle(DeviceProperties.Device);

		// camera.updateAspectRatio((float)width / (float)height);

		// Notify derived class
		WindowResized();
		ViewChanged();

		RenderProperties.Prepared = true;
	}

	// Default ctor
	vulkan_constructor(renderer_platform& Platform, bool32 VulkanEnableValidation, VkPhysicalDeviceFeatures VulkanEnabledFeatures)
	{
		// Window = (HWND)Platform.Window;
		// WindowInstance = (HINSTANCE)Platform.Instance;

		// Check for validation command line flag
		/*
		for (int32 i = 0; i < __argc; i++)
		{
		if (__argv[i] == std::string("-validation"))
		{
		enableValidation = true;
		}
		if (__argv[i] == std::string("-vsync"))
		{
		enableVSync = true;
		}
		}
		*/

		BaseProperties.EnabledFeatures = VulkanEnabledFeatures;

		// Enable console if validation is active
		// Debug message callback will output to it
		if (VulkanEnableValidation)
		{
			// setupConsole("VulkanExample");
		}
	}

	// dtor
	/*
	~renderer()
	{
		// Clean up Vulkan resources
		SwapChain.Cleanup();
		if (DescriptorPool != VK_NULL_HANDLE)
		{
			vkDestroyDescriptorPool(Device, DescriptorPool, nullptr);
		}
		if (SetupCommandBuffer != VK_NULL_HANDLE)
		{
			vkFreeCommandBuffers(Device, CommandPool, 1, &SetupCommandBuffer);

		}
		DestroyCommandBuffers();
		vkDestroyRenderPass(Device, RenderPass, nullptr);
		for (uint32 Index = 0; Index < FrameBuffersCount; Index++)
		{
			vkDestroyFramebuffer(Device, FrameBuffers[Index], nullptr);
		}

		for (VkShaderModule* Module = ShaderModules; *Module; ++Module)
		{
			vkDestroyShaderModule(Device, *Module, nullptr);
		}
		vkDestroyImageView(Device, DepthStencil.View, nullptr);
		vkDestroyImage(Device, DepthStencil.Image, nullptr);
		vkFreeMemory(Device, DepthStencil.Memory, nullptr);

		vkDestroyPipelineCache(Device, PipelineCache, nullptr);

		vkDestroyCommandPool(Device, CommandPool, nullptr);

		vkDestroySemaphore(Device, Semaphores.PresentComplete, nullptr);
		vkDestroySemaphore(Device, Semaphores.RenderComplete, nullptr);

		delete EncapsulatedDevice;

		if (EnableValidation)
		{
			if(MessageCallback)
			{
				vkDestroyDebugReportCallbackEXT(Instance, MessageCallback, nullptr);
			}
		}

		vkDestroyInstance(Instance, nullptr);
	}
	*/

	// Get window title with example name, device, et.
	const char* GetWindowTitle()
	{
		return BaseProperties.ApplicationName;
	}

	// Setup the vulkan instance, enable required extensions and connect to the physical device (GPU)
	void InitializeVulkan(bool32 VulkanEnableValidation)
	{
		VkResult Error;

		// Vulkan instance
		Error = CreateInstance(VulkanEnableValidation);
		if (Error)
		{
			DebugOutput((char *)Error);
		}

		// If requested, we enable the default validation layers for debugging
		if (VulkanEnableValidation)
		{
			// The report flags determine what type of messages for the layers will be displayed
			// For validating (debugging) an appplication the error and warning bits should suffice
			VkDebugReportFlagsEXT debugReportFlags = VK_DEBUG_REPORT_ERROR_BIT_EXT; // | VK_DEBUG_REPORT_WARNING_BIT_EXT | VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT;
																					// Additional flags include performance info, loader and layer debug messages, etc.
			SetupDebugging(Instance, debugReportFlags, VK_NULL_HANDLE);
		}

		
		DeviceProperties.SetupDevice(Instance, Queue);


		// Find a suitable depth format
		VkBool32 IsValidDepthFormat = DeviceProperties.GetSupportedDepthFormat(&CommandBuffers.DepthFormat);
		Assert(IsValidDepthFormat);

		SwapChain.Connect(Instance, DeviceProperties.PhysicalDevice, DeviceProperties.Device);

		// Create synchronization objects
		VkSemaphoreCreateInfo SemaphoreCreateInfo = { };
		SemaphoreCreateInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
		SemaphoreCreateInfo.pNext = NULL;
		SemaphoreCreateInfo.flags = 0;

		// Create a semaphore used to synchronize image presentation
		// Ensures that the image is displayed before we start submitting new commands to the queu
		VK_CHECK_RESULT(vkCreateSemaphore(Device, &SemaphoreCreateInfo, nullptr, &Semaphores.PresentComplete));
		// Create a semaphore used to synchronize command submission
		// Ensures that the image is not presented until all commands have been sumbitted and executed
		VK_CHECK_RESULT(vkCreateSemaphore(Device, &SemaphoreCreateInfo, nullptr, &Semaphores.RenderComplete));
		// Create a semaphore used to synchronize command submission
		// Ensures that the image is not presented until all commands for the text overlay have been sumbitted and executed
		// Will be inserted after the render complete semaphore if the text overlay is enabled
		// VK_CHECK_RESULT(vkCreateSemaphore(Device, &SemaphoreCreateInfo, nullptr, &Semaphores.textOverlayComplete));

		// Set up submit info structure
		// Semaphores will stay the same during application lifetime
		// Command buffer submission info is set by each example
		SubmitInfo = { };
		SubmitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
		SubmitInfo.pNext = NULL;

		SubmitInfo.pWaitDstStageMask = &PipelineProperties.SubmitPipelineStages;
		SubmitInfo.waitSemaphoreCount = 1;
		SubmitInfo.pWaitSemaphores = &Semaphores.PresentComplete;
		SubmitInfo.signalSemaphoreCount = 1;
		SubmitInfo.pSignalSemaphores = &Semaphores.RenderComplete;
	}

	void Draw()
	{
		PrepareFrame();

		// Command buffer to be sumitted to the queue
		SubmitInfo.commandBufferCount = 1;
		SubmitInfo.pCommandBuffers = CommandBuffers.GetCurrentDrawBuffer();

		// Submit to queue
		VK_CHECK_RESULT(vkQueueSubmit(Queue, 1, &SubmitInfo, VK_NULL_HANDLE));

		SubmitFrame();
	}

	void UpdateUniformBuffers()
	{
		// glm::mat4 perspective = glm::perspective(glm::radians(60.0f), (float)width / (float)height, 0.001f, 256.0f);
		// for (auto& gear : gears)
		// {
		//  	gear->updateUniformBuffer(perspective, rotation, zoom, timer * 360.0f);
		// }
	}

	// Pure virtual render function (override in derived class)
	void Render()
	{
		if(!RenderProperties.Prepared)
		{
			return;
		}

		vkDeviceWaitIdle(DeviceProperties.Device);
		Draw();
		vkDeviceWaitIdle(DeviceProperties.Device);
		if (!RenderProperties.Paused)
		{
			UpdateUniformBuffers();
		}
	}

	// Called when view change occurs
	// Can be overriden in derived class to e.g. update uniform buffers 
	// Containing view dependant matrices
	void ViewChanged()
	{
		UpdateUniformBuffers();
	}

	// Called when the window has been resized
	// Can be overriden in derived class to recreate or rebuild resources attached to the frame buffer / swapchain
	void WindowResized()
	{
		// Can be overriden in derived class
	}

	// Setup default depth and stencil views
	void SetupDepthStencil()
	{
		VkImageCreateInfo Image = {};
		Image.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
		Image.pNext = NULL;
		Image.imageType = VK_IMAGE_TYPE_2D;
		Image.format = DepthFormat;
		Image.extent = { Width, Height, 1 };
		Image.mipLevels = 1;
		Image.arrayLayers = 1;
		Image.samples = VK_SAMPLE_COUNT_1_BIT;
		Image.tiling = VK_IMAGE_TILING_OPTIMAL;
		Image.usage = VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT | VK_IMAGE_USAGE_TRANSFER_SRC_BIT;
		Image.flags = 0;

		VkMemoryAllocateInfo MemoryAllocInfo = {};
		MemoryAllocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
		MemoryAllocInfo.pNext = NULL;
		MemoryAllocInfo.allocationSize = 0;
		MemoryAllocInfo.memoryTypeIndex = 0;

		VkImageViewCreateInfo DepthStencilView = {};
		DepthStencilView.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
		DepthStencilView.pNext = NULL;
		DepthStencilView.viewType = VK_IMAGE_VIEW_TYPE_2D;
		DepthStencilView.format = DepthFormat;
		DepthStencilView.flags = 0;
		DepthStencilView.subresourceRange = {};
		DepthStencilView.subresourceRange.aspectMask = VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT;
		DepthStencilView.subresourceRange.baseMipLevel = 0;
		DepthStencilView.subresourceRange.levelCount = 1;
		DepthStencilView.subresourceRange.baseArrayLayer = 0;
		DepthStencilView.subresourceRange.layerCount = 1;

		VkMemoryRequirements MemoryRequirements;

		VK_CHECK_RESULT(vkCreateImage(Device, &Image, nullptr, &DepthStencil.Image));
		vkGetImageMemoryRequirements(Device, DepthStencil.Image, &MemoryRequirements);
		MemoryAllocInfo.allocationSize = MemoryRequirements.size;
		MemoryAllocInfo.memoryTypeIndex = EncapsulatedDevice->GetMemoryType(MemoryRequirements.memoryTypeBits, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);
		VK_CHECK_RESULT(vkAllocateMemory(Device, &MemoryAllocInfo, nullptr, &DepthStencil.Memory));

		VK_CHECK_RESULT(vkBindImageMemory(Device, DepthStencil.Image, DepthStencil.Memory, 0));
		SetImageLayout(
			SetupCommandBuffer,
			DepthStencil.Image,
			VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT,
			VK_IMAGE_LAYOUT_UNDEFINED,
			VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL);

		DepthStencilView.image = DepthStencil.Image;
		VK_CHECK_RESULT(vkCreateImageView(Device, &DepthStencilView, nullptr, &DepthStencil.View));
	}
	// Setup a default render pass
	// Can be overriden in derived class to setup a custom render pass (e.g. for MSAA)
	void SetupRenderPass()
	{
		VkAttachmentDescription Attachments[2] = {};

		// Color attachment
		Attachments[0].format = Colorformat;
		Attachments[0].samples = VK_SAMPLE_COUNT_1_BIT;
		Attachments[0].loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
		Attachments[0].storeOp = VK_ATTACHMENT_STORE_OP_STORE;
		Attachments[0].stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
		Attachments[0].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
		Attachments[0].initialLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
		Attachments[0].finalLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

		// Depth attachment
		Attachments[1].format = DepthFormat;
		Attachments[1].samples = VK_SAMPLE_COUNT_1_BIT;
		Attachments[1].loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
		Attachments[1].storeOp = VK_ATTACHMENT_STORE_OP_STORE;
		Attachments[1].stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
		Attachments[1].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
		Attachments[1].initialLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;
		Attachments[1].finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;

		VkAttachmentReference ColorReference = {};
		ColorReference.attachment = 0;
		ColorReference.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

		VkAttachmentReference DepthReference = {};
		DepthReference.attachment = 1;
		DepthReference.layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;

		VkSubpassDescription Subpass = {};
		Subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
		Subpass.flags = 0;
		Subpass.inputAttachmentCount = 0;
		Subpass.pInputAttachments = NULL;
		Subpass.colorAttachmentCount = 1;
		Subpass.pColorAttachments = &ColorReference;
		Subpass.pResolveAttachments = NULL;
		Subpass.pDepthStencilAttachment = &DepthReference;
		Subpass.preserveAttachmentCount = 0;
		Subpass.pPreserveAttachments = NULL;

		VkRenderPassCreateInfo RenderPassInfo = {};
		RenderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
		RenderPassInfo.pNext = NULL;
		RenderPassInfo.attachmentCount = 2;
		RenderPassInfo.pAttachments = Attachments;
		RenderPassInfo.subpassCount = 1;
		RenderPassInfo.pSubpasses = &Subpass;
		RenderPassInfo.dependencyCount = 0;
		RenderPassInfo.pDependencies = NULL;

		VK_CHECK_RESULT(vkCreateRenderPass(Device, &RenderPassInfo, nullptr, &RenderPass));
	}

	// Connect and prepare the swap chain
	void InitializeSwapchain()
	{
		SwapChain.InitializeSurface(*DeviceProperties.Platform);
	}
	// Create swap chain images
	void CreateSwapChainImages()
	{
		SwapChain.Create(&RenderProperties.Width, &RenderProperties.Height, BaseProperties.EnableVSync);
	}

	// Prepare commonly used Vulkan functions
	void Prepare()
	{
		if (EnableDebugMarkers)
		{
			SetupDebug(Device);
		}
		CreateCommandPool();
		CreateSetupCommandBuffer();
		CreateSwapChainImages();
		CreateCommandBuffers();
		BuildPresentCommandBuffers();
		SetupDepthStencil();
		SetupRenderPass();
		CreatePipelineCache();
		SetupFrameBuffer();
		FlushSetupCommandBuffer();
		// Recreate setup command buffer for derived class
		CreateSetupCommandBuffer();
		// Create a simple texture loader class
	}

	VkShaderModule LoadShader(const char *FileName, VkDevice VulkanDevice, VkShaderStageFlagBits ShaderStage)
	{
		char* Buffer = (char *)MemAlloc(sizeof(char) * 256, 8);

		GetFileContents(FileName, Buffer);

		memory_index Size = 0;

		for(char* Character = Buffer; *Character; ++Character)
		{
			Size++;
		}

		VkShaderModule ShaderModule;
		VkShaderModuleCreateInfo ModuleCreateInfo;
		ModuleCreateInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
		ModuleCreateInfo.pNext = NULL;
		ModuleCreateInfo.codeSize = Size;
		ModuleCreateInfo.pCode = (uint32 *)Buffer;
		ModuleCreateInfo.flags = 0;

		VK_CHECK_RESULT(vkCreateShaderModule(VulkanDevice, &ModuleCreateInfo, NULL, &ShaderModule));

		MemDealloc(Buffer);

		return ShaderModule;
	}

	// Load a SPIR-V shader
	VkPipelineShaderStageCreateInfo LoadShader(const char* FileName, VkShaderStageFlagBits ShaderStage)
	{
		VkPipelineShaderStageCreateInfo ShaderStageCreateInfo = {};
		ShaderStageCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
		ShaderStageCreateInfo.stage = ShaderStage;

		ShaderStageCreateInfo.module = LoadShader(FileName, Device, ShaderStage);

		ShaderStageCreateInfo.pName = "main"; // todo : make param
		Assert(ShaderStageCreateInfo.module != NULL);

		ShaderModules[ShaderCount++] = ShaderStageCreateInfo.module;
		return ShaderStageCreateInfo;
	}

	// Start the main render loop
	void RenderLoop()
	{
		DestinationWidth = Width;
		DestinationHeight = Height;
		// Flush device to make sure all resources can be freed 
		vkDeviceWaitIdle(Device);
	}

	// Prepare a submit info structure containing
	// semaphores and submit buffer info for vkQueueSubmit
	VkSubmitInfo PrepareSubmitInfo(
		VkCommandBuffer* CommandBuffers,
		VkPipelineStageFlags* PipelineStages)
	{
		VkSubmitInfo CommandBufferSubmitInfo = { };
		CommandBufferSubmitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
		CommandBufferSubmitInfo.pNext = NULL;

		CommandBufferSubmitInfo.pWaitDstStageMask = PipelineStages;
		CommandBufferSubmitInfo.waitSemaphoreCount = 1;
		CommandBufferSubmitInfo.pWaitSemaphores = &Semaphores.PresentComplete;
		CommandBufferSubmitInfo.commandBufferCount = CommandBufferCount;
		CommandBufferSubmitInfo.pCommandBuffers = CommandBuffers;
		CommandBufferSubmitInfo.signalSemaphoreCount = 1;
		CommandBufferSubmitInfo.pSignalSemaphores = &Semaphores.RenderComplete;
		return CommandBufferSubmitInfo;
	}

	// Prepare the frame for workload submission
	// - Acquires the next image from the swap chain 
	// - Submits a post present barrier
	// - Sets the default wait and signal semaphores
	void PrepareFrame()
	{
		// Acquire the next image from the swap chaing
		VK_CHECK_RESULT(SwapChain.AcquireNextImage(Semaphores.PresentComplete, &CurrentBuffer));

		// Submit post present image barrier to transform the image back to a color attachment that our render pass can write to
		VkSubmitInfo FrameSubmitInfo = {};
		FrameSubmitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
		FrameSubmitInfo.pNext = NULL;

		FrameSubmitInfo.commandBufferCount = 1;
		FrameSubmitInfo.pCommandBuffers = &PostPresentCommandBuffers[CurrentBuffer];
		VK_CHECK_RESULT(vkQueueSubmit(Queue, 1, &FrameSubmitInfo, VK_NULL_HANDLE));
	}

	// Submit the frames' workload 
	// - Submits the text overlay (if enabled)
	// - 
	void SubmitFrame()
	{
		// Submit pre present image barrier to transform the image from color attachment to present(khr) for presenting to the swap chain
		VkSubmitInfo FrameSubmitInfo = {};
		FrameSubmitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
		FrameSubmitInfo.pNext = NULL;

		FrameSubmitInfo.commandBufferCount = 1;
		FrameSubmitInfo.pCommandBuffers = &PrePresentCommandBuffers[CurrentBuffer];
		VK_CHECK_RESULT(vkQueueSubmit(Queue, 1, &FrameSubmitInfo, VK_NULL_HANDLE));

		// VK_CHECK_RESULT(swapChain.queuePresent(queue, currentBuffer, submitTextOverlay ? semaphores.textOverlayComplete : semaphores.renderComplete));
		VK_CHECK_RESULT(SwapChain.QueuePresent(Queue, CurrentBuffer, Semaphores.RenderComplete));

		VK_CHECK_RESULT(vkQueueWaitIdle(Queue));
	}
};

class renderer
{	

	// std::vector<VulkanGear*> gears;

	
};

#endif